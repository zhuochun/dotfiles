#!/usr/bin/env ruby
# encoding: utf-8

# Pass the command to ChatGPT and return the response
#
# Usage: ai-chat "Explain concept"
# Usage: ai-chat file.txt -i
# Usage: ai-chat file.txt --model=gpt-4o
#
# Requires OpenAI API Key stored in DOT_OPENAI_KEY
#
# Overwrite keys in Windows Powershell
#
# $env:DOT_OPENAI_KEY=xxx
# $env:DOT_OPENAI_URL=xxx

require 'optparse'

require_relative "../scripts/utils-ai"
check_ai_env()

options = {} # arg options

OptionParser.new do |opts|
  opts.banner = "Usage: ai-chat [msg | file.txt] [options]"

  opts.on("-i", "Run in insert mode, replace the original file") do
    options[:insert_mode] = true
  end

  opts.on("-git", "Run git commit after file edits") do
    options[:git_enabled] = true
  end

  opts.on("--prompt=PROMPT", "Specify a prompt file as system message") do |prompt|
    options[:system_prompt] = prompt
  end

  opts.on("--model=MODEL", "Specify the model (e.g., gpt4)") do |model|
    options[:model] = model
  end
end.parse!

STDOUT << "Use options: #{options}\n"

# get the prompt (it should be the first argument, either a file or a message)
prompt = ARGV[0]

if prompt.nil?
  STDOUT << "Invalid arguments received\n"
  exit 1
end

msgs = []

if File.exist?(prompt) # if the prompt is a file, read it
  options[:file_mode] = true
  msgs = open_file(prompt)
else
  options[:file_mode] = false
  msgs << { :role => ROLE_USER, :content => prompt }
end

if msgs.empty? || msgs.last[:role] == ROLE_ASSISTANT
  STDOUT << "No USER prompt message: #{prompt}\n"
  exit 1
end

unless options[:system_prompt].nil? # handle system prompt files
  sys_prompt = File.read(options[:system_prompt])

  if msgs[0][:role] == ROLE_SYSTEM # merge with existing system prompt
    msgs[0][:content] += "\n" + sys_prompt
  else
    msgs.unshift({ :role => ROLE_SYSTEM, :content => sys_prompt })
  end
end

STDOUT << "Run prompt #{Time.now}\n"

model_opts = {}
model_opts["model"] = options[:model] unless options[:model].nil?

resp = chat_resp(msgs, model_opts)
msgs << { :role => ROLE_ASSISTANT, :content => resp }

unless options[:file_mode] # output in terminal
  STDOUT << msgs.last[:content] << "\n"
  exit
end

if options[:insert_mode] # write only the resp
  write_file(prompt, [msgs.last])
else
  append_file(prompt, [msgs.last, { :role => ROLE_USER, :content => "" }])
end

if options[:git_enabled] # make a timestamp commit
  require_relative "../scripts/utils-git"
  commit_git(File.dirname(prompt), "Auto commit #{Time.now}")
end
