#!/usr/bin/env ruby
# encoding: utf-8

# Index all markdown files in a directory
#
# Usage: ai-rag-index dir-path index-file
# Usage: ai-rag-index dir-path index-file -gpt
#
# Requires OpenAI API Key stored in DOT_OPENAI_KEY

require_relative "../scripts/utils-ai"

require 'digest'

OPT_GPT = ARGV.delete('-gpt') # use open-ai's embedding instead
if OPT_GPT
    OPENAI_KEY = ENV["DOT_OPENAI_KEY"] || ""
    if OPENAI_KEY.empty?
        STDOUT << "Remember to set env DOT_OPENAI_KEY\n"
        exit 9
    end
end

if ARGV.length != 2
    STDOUT << "Invalid arguments received\n"
    exit 1
end

dir = ARGV[0].gsub(/^\./, Dir.pwd) # Replace relative dir to absolute directory
dir = File.join(*dir.split(File::ALT_SEPARATOR || File::SEPARATOR), '**', '*.{md,markdown}')

files = Dir[dir]
STDOUT << "Scan directory: #{dir}, Found: #{files.length}\n"

def file_content(file)
    content = ""

    File.foreach(file) do |line|
        if line.start_with?(/- .+:/) || line.start_with?('  - [[') # yaml like
            next
        elsif line.start_with?('<') # html like
            next
        else
            content << line unless line.strip.empty?
        end
    end

    content
end

STDOUT << "Scanning index @#{Time.now}\n"
DB = {} # hash: item
File.foreach(ARGV[1]) do |line|
    item = JSON.parse(line)

    DB[item["hash"]] = item
end if File.exist?(ARGV[1])
STDOUT << "Found index: #{DB.length}\n"

STDOUT << "Building index @#{Time.now}\n["
skipped = 0
File.open(ARGV[1], 'w') do |index_db|
    files.each_with_index do |file, idx|
        content = file_content(file)
        hash = Digest::SHA256.hexdigest(content)

        if DB[hash] # found in old DB
            index_db.puts(DB[hash].to_json)

            skipped += 1
            next
        end

        embedding = if OPT_GPT then embedding(content) else embedding_ollama(content) end
        line = { path: file, hash: hash, embedding: embedding }
        index_db.puts(line.to_json)

        if idx % 50 == 0
            index_db.flush # a little careful

            STDOUT << idx
        else
            STDOUT << "."
        end
    end
end
STDOUT << "]\nDone @#{Time.now}\n"
STDOUT << "Skipped: #{skipped}\n"